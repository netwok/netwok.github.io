---
layout: default
---

<html>
  <head>

<h2>Here I post my solutions for the Project Euler challenges</h2>

1.
<pre>
 <code>
  sum([i for i in range(1,n) if (i)%3==0 or (i)%5==0])
 </code>
</pre>

2.
<pre>
 <code>
def even_fib(lim):
    num1 = 1
    num2 = 2
    while num2 < lim:
        if num2%2==0:
            yield num2
        num1, num2 = num2, num1+num2 #update fibonacci numbers for next pass
    
sum(even_fib(4000000))
  </code>
 </pre>
3.
<pre>
 <code>
def primes(n):
    fac = 2
    end = n
    maxi = -1
    
    while fac <= n:
        print('trying fac {}'.format(fac))
        while n%fac == 0:
            print('success')
            n=int(n/fac)
            print('end is {}'.format(n))
            maxi = fac
        fac += 1
    return maxi

primes(600851475143)
  </code>
 </pre>

4.
def is_pal(n):
    l = list(str(n))
    while l:
        if l[0]==l[-1]:
            del l[0]
            try:
                del l[-1]
            except:
                pass
        else:
            return False
    return True
    
def get_pal():
    ans = (0,0,0)
    for i in range(1, 1000):
        for j in range(1,1000):
            if is_pal(i*j):
                if i*j > ans[0]:
                    ans = (i*j,i,j)
    return ans
    
get_pal()

5.
def hard():
    i = 2520
    found = False
    while found == False:
        found = True
        for j in range(1, 21):
            if i%j == 0:
                pass
            else:
                found = False
                i += 2
    return i
    
hard()

also:
<-- import pandas as pd

def primes(n):
    fac = 2
    end = n
    pri = []
    
    while fac <= n:
        while n%fac == 0:
            print('success')
            n=int(n/fac)
            pri.append(fac)
        fac += 1
    return pri


def all_primes(n):
    totals = []
    for i in range(2, n+1):
        totals.append(primes(i))
    return totals
    
all_primes(4) -->


6.
def sum_sq(n = 100):
    sum = 0
    for i in range(1,n+1):
        sum = sum + (i*i)
    return sum
    
def sq_sum(n = 100):
    sum = 0
    for i in range(1,n+1):
        sum = sum + i
    return sum * sum
    
7.
def isprime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2==0:
        return False
    for i in range(3, n, 2):
        if n%i == 0:
            return False
    return True

def getprime(n):
    if n == 1:
        return 2
    i = 3
    count = 3
    while count <= n:
        i += 2
        count += isprime(i)
    return i

    
sum_sq() - sq_sum()

8.
#bigstr = str(big)
#spl = bigstr.split('0')
#cut = [i for i in spl if len(i) > 12]

def mult(string):
    p = 1
    for i in range(len(string)):
        p = p*int(string[i])
    return p

def get_max_13(string):
    p = 0
    for i in range(len(string)-12):
        multi = mult(string[i:i+13])
        if multi > p:
            p = multi
            best = string[i:i+13]
    return (p, best)

prod = 0
for string in cut:
    score, line = get_max_13(string)
    if score > prod:
        prod = score
        best = line

print(prod)
print(best)


9.
def sumprimes(n):
    p = [2,3,5]
    summation = 10
    k = 7
    odd = True
    while k < n:
        for i in p:
            if k%i == 0:
                break
        p.append(k)
        summation += k
        k = k + 2 + 2*odd        
        odd = not(odd)
    print(p)
    return summation
        
sumprimes(2000000)

11.
###
#preliminaries:
import numpy as np

st = '08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08,49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00,81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65,52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91,22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80,24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50,32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70,67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21,24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72,21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95,78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92,16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57,86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58,19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40,04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66,88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69,04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36,20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16,20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54,01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48'

g = st.split(',')
x = [int(a) for a in g]
array = np.array(x)
array.shape = (20,20)

###
#solving
tot = 0

#first the horizontals
for row in range(20):
    for col in range(17):
        git = np.prod(array[row][col:col+4])
        if git > tot:
            tot = git
            loca = (row, col, 'h')
            print(tot, loca)
        
#then the verticals
for row in range(17):
    for col in range(20):
        git = array[row][col] * array[row+1][col] * array[row+2][col] * array[row+3][col]
        if git > tot:
            tot = git
            loca = (row, col, 'v')
            print(tot, loca)
        
        
#then bottom-right diagonals
for row in range(17):
    for col in range(17):
        git = array[row][col] * array[row+1][col+1] * array[row+2][col+2] * array[row+3][col+3]
        if git > tot:
            tot = git
            loca = (row, col, 'r')
            print(tot, loca)
        
        
#then bottom-left diagonals
for row in range(17):
    for col in range(3,20,1):
        git = array[row][col] * array[row+1][col-1] * array[row+2][col-2] * array[row+3][col-3]
        if git > tot:
            tot = git
            loca = (row, col, 'l')
            print(tot, loca)
final print gives answer and location

12.
def get_primes(n):
    from collections import defaultdict
    fac = 2
    maxi = defaultdict(int)
    
    while fac <= n:
        while n%fac == 0:
            n=int(n/fac)
            maxi[fac] += 1
        fac += 1
    return maxi

def num_facs(n):
    ms = get_primes(n)
    score = 1
    for val in ms.values():
        score = score * (val+1)
    score = score - 1
    print(score)
    return score
    
def gen_triangles(n):
    s = 0
    k = 1
    while(s<n):
        print('k = ', k)
        s += k
        k += 1
        yield s
    
def first_with_lots(n=500):
    for tri in gen_triangles(1000000000):
        print('trying ',tri)
        if num_combis(tri) >= n:
            return tri
    else:
        print('oops')
        

first_with_lots()
    
13.
big = """ (the numbers) """

bigs = big.split('\n')
lits = [int(num) for num in bigs]
sum(lits)

14.

def getcol(upto):
    #finds distance(n) recursively
    def thiscol(n):
        n = int(n)
        #when we reach a previous position, don't recalculate
        if n < upto and collatz[n] > 0:
            return collatz[n]
        if n%2 == 0:
            #print('even! going down to ',str(int(n/2)))
            val = thiscol(n/2) + 1
        else:
            #print('odd! going up to ',str(3*n + 1))
            val = thiscol((3*n + 1)/2) + 2
        if n<upto:
            collatz[n] = val
        return val
    
    collatz = [-1]* upto
    collatz[1] = 1
    #if there is any number where distance is not defined
    #while -1 in collatz[1:1000000]:
    for i in range(1 + int(upto/2),upto):
        collatz[i] = thiscol(i)
    return collatz.index(max(collatz))
    #print('max is ',collatz.index(max(collatz)),' with distance ', max(collatz))
    #return collatz.index(max(collatz))
    
15. lattice paths

   def ans(n):
    n += 1
    import numpy as np
    top = np.array([[1]*n])
    rest = np.zeros((n-1,n))
    full = np.vstack([top,rest])
    def score(i,j):
        #we're only going to work with the top-right half of the matrix as it is symmetrical
        if i > j:
            i,j=(j,i)
        if full[i,j] == 0:
            val = score(i-1,j) + score(i,j-1)
            full[i,j] = val
            return val
        else:
            return full[i,j]
    return score(n-1,n-1)
    
16.
s = 0
for i in str(2**1000):
s += int(i)
print(s)
    
18.
grid = [[75],[95,64],[17,47,82],[18,35,87,10],[20,4,82,47,65],[19,1,23,75,3,34],[88,2,77,73,7,63,67],[99,65,4,28,6,16,70,92],[41,41,26,56,83,40,80,70,33],[41,48,72,33,47,32,37,16,94,29],[53,71,44,65,25,43,91,52,97,51,14],[70,11,33,28,77,73,17,78,39,68,17,57],[91,71,52,38,17,14,91,43,58,50,27,29,48],[63,66,4,68,89,53,67,30,73,16,69,87,40,31],[4,62,98,27,23,9,70,98,73,93,38,53,60,4,23]]
#start from the bottom, store longest path for each position in list

19. mons = ['jan',
         'feb',
         'mar',
         'apr',
         'may',
         'june',
         'july',
         'aug',
         'sept',
         'oct',
         'nov',
         'dec']

lens = {'jan':31,
 'feb':28,
 'mar':31,
 'apr':30,
 'may':31,
 'june':30,
 'july':31,
 'aug':31,
 'sept':30,
 'oct':31,
 'nov':30,
 'dec':31}
 
days = ['sun','mon','tue','wed','thur','fri','sat']
count = 0
runner = 1
for i in ___:
    lens['feb'] = (   )
    runner += lens[mon[i%12]]
    count += days[runner%7] == 'sun'
print(count)
          
21.
def get_primes(n):
    from collections import defaultdict
    fac = 2
    maxi = defaultdict(int)
    
    while fac <= n:
        while n%fac == 0:
            n=int(n/fac)
            maxi[fac] += 1
        fac += 1
    return maxi

def get_divs(n):
    ms = get_primes(n)
    superlist = set([1])
    
    for key, val in ms.items():
        temp = set()
        for i in range(1,val+1):
            for bit in superlist:
                temp.add(bit*key**i)
        superlist.update(temp)
    superlist.remove(n)
    print(superlist)
    return sum(superlist)

          
22.
def get_primes(n):
    from collections import defaultdict
    fac = 2
    maxi = defaultdict(int)
    
    while fac <= n:
        while n%fac == 0:
            n=int(n/fac)
            maxi[fac] += 1
        fac += 1
    return maxi
    
def abun(n):
    ms = get_primes(n)
    superlist = set([1])
    
    for key, val in ms.items():
        temp = set()
        for i in range(1,val+1):
            for bit in superlist:
                temp.add(bit*key**i)
        superlist.update(temp)
    superlist.remove(n)
    return sum(superlist) > n
    

#import numpy as np
ans = np.array([i for i in range(1,28123)])
#abuns = np.array([i for i in range(1,28123) if abun(i)])

def makeable(n):
    x = abuns[np.where(abuns < n)]
    for i in x:
        for j in x:
            if i + j == n:
                return True
    return False

          
23.
from itertools import permutations
ss2 = permutations('0123456789',10)            
def millionth():
    for i in range(0,999999):
        next(ss2)
    print(next(ss2))
          
25.
def fib():
    a = 1
    b = 1
    while True:
        yield a
        a,b = b, a+b
        
def soln(lim):
    nums = fib()
    count = 1
    while True:
        if next(nums) > lim:
            return count
        count += 1
        
soln(10**999)

27. #Quadratic Primes
primes = sieve() #as per Q35

def islucky(a,b,primes):
    count = 0
    n = 0
    isprime = True
    while isprime:
        isprime = (n**2 +a*n +b) in primes
        count += isprime
        n += 1
    return count
    
def ans():
    biggest = 40
    product = 41
    #b must be odd because of n == 0
    #a must be odd because of n == 1, and b being odd
    for a in range(-999,1001,2):
        for b in range(-999,1001,2):
            count = islucky(a,b,primes)
            if count > biggest:
                product = a*b
                biggest = count
    return product
          
28.
          #generator to find next four numbers in spiral and increase side length by 2 each time
def few():
    a = 1
    jump = 2
    while True:
        c = [a,a+jump,a+jump*2,a+jump*3]
        a = c[3]+jump
        jump = jump + 2
        yield c

          #runs the generator and adds up the sum until the top-riht corner is reached
def ans(n=1001):
    some = few()
    total = 0
    c = [0]
    while c[0] < n**2:
        c = next(some)
        total += sum(c)
    #exclude the outer layer as we have overshot, but include the top-right corner (i.e. c[0] or this iteration)
    return total - sum(c) + n

29. 
def comb(a,b):
    s = set()
    for i in range(2,a+1):
        for j in range(2,b+1):
            s.add(i**j)
    return s

30.
# 354294 == 5*(9**5) is our upper limit
[i for i in range(2,354294) if i == sum([int(i) ** 5 for i in str(i)])]
          
31.
write an algorithm to do the following process to find all permutations, adding smaller coins when target is met or overshot: 

valindex = 0 #edit first coin
[200] sum == 200 #reached target, add to set, try smaller coin in valindex [200]
[100] sum == 100 # less than target, increase valindex
    valindex = 1
    [.. 100], sum == 200 #reached target, add to set, try smaller coin in valindex [100,100]
    [.. 50], sum == 150 # less than target, increase valindex
        valindex = 2
        [.. 50] sum == 200 #reached target, add to set, try smaller coin in valindex [100,50,50]
        [.. 20] sum == 170 # less than target, increase valindex
            valindex = 3
            #add a 20p coin here
            [.. 20] sum == 210 #overshot, try smaller coin in valindex
            [.. 10] sum == 200 #reached target, add to set, try smaller coin in valindex 
            [.. 5] sum == 195 # less than target, increase valindex
                valindex = 4
                [.. 5] sum == 200 #reached target, add to set, try smaller coin in valindex
                [.. 2] sum = 197 # less than target, increase valindex
                    valindex = 5
                    [.. 2] sum = 199 # less than target, increase valindex
                        valindex = 6
                        [.. 2] sum = 201 #overshot, try smaller coin in valindex
                        [.. 1] sum = 200 #reached target, add to set, try smaller coin before valindex
                    valindex = 5
                    [.. 1] sum = 198 # less than target, increase valindex
                        valindex = 6
                        [.. 1] sum = 199
                            valindex = 7
                            [.. 1] sum = 200 #reached target, add to set, try smaller coin before valindex
                        valindex = 6 #nothing smaller than penny
                    valindex = 5 #nothing smaller than penny
                valindex = 4
                        
as a start:
def find():
    valindex = 0
    coins = [200, 100, 50, 20, 10, 5, 2, 1]
    size = 0
    ans = 0
    this = []
    while len(this < 200):
        for i in range(size,8):
            if sum(this.append([coins[i]])) < 200:
                valindex += 1
            if sum(this.append([coins[i]])) == 200:
                ans += 1
            if sum(this.append([coins[i]])) > 200:
                valindex += -1
#this code is way to slow, there is no need to mess about with the pennies like that.. better solution would be to calculate number of ways to make each sub-amount (stored in list) and work up to 200
          
32.
def isprod(stri):
    #string is a permutation of the nine digits
    c = int(stri[5:])
    for i in [2,1]:
            a = int(stri[0:i])
            b = int(stri[i:5])
            if a*b == c:
                return c
    return 0

def ans():
    from itertools import permutations
    vals = set()
    for perm in permutations('123456789'):
        vals.add(isprod(''.join(perm))) 
    return sum(vals)

ans()
          
#pretty quick

33.
def isfrac(a,b):
             A = str(a)
             B = str(b)
             if A[-1] == B[0]:
                 if a/b == int(A[:-1])/int(B[1:]):
                     return True
             return False
         

def ans():
    v = 1
    for a in range(10, 100):
        for b in [i for i in range(a+1,100) if i%10 > 0]:
            if isfrac(a,b):
                v = v * b/a
    return v
                 
ans()
          
#all candidate answers can be written in the form [ab, bc] with c>a, b>a.
#Code should evaluate only these possibilities to get rid of an if in the 1st function and run fewer iterations in the 2nd.

34.
from math import factorial as f

def isdf(n):
    magic = sum([f(int(digit)) for digit in str(n)])
    return magic*(magic==n)
    
def ans():
    for i in range(3,1000000):
        x = isdf(i)
        if x>0:
            print(x)
          
#could have predefined the factorials to save time

35. Circular Primes
#implement a sieve to find all primes under 1 million
#run circ(n) on each element of that list, counting the Trues

def sieve(lim=1000000):
    primes = [n for n in range(3,lim,2)]
    for prime in primes:
        #we don't want to bother multiplying through the numbers that we have already marked off as non-primes
        if prime > 2:
            #all primes over 2 are odd so I'm mapping indicies to numbers with n = 2i+3 (e.g. n = 3, 5, 7, etc. for i = 0, 1, 2)
            for mult in range(3,int(lim/prime)+1,2):
                #a sneaky way to make sure 2 is listed as prime, set score for non-primes as 2
                primes[int((prime*mult)/2-1.5)] = 2
    #removes all those extra 2's and condenses output to reduce space
    return set(primes)
    
def circ(n,primes):
    #n must be prime itself, so we assume it is
    string = str(n)
    end = len(string)
    #then check each rotation by splitting the string at each point internally
    for split in range(1,end):
        #using our swet of primes from before
        if int(string[split:end]+string[0:split]) not in primes:
            return False
    return True
    
primes = sieve()

count = 0
for n in primes:
    count += circ(n,primes)
print(count)

#this one runs really quickly, sieves and solves in less than a second on Datacamp server

36.
def ispal(n):
    for l in [list(str(n)),list(format(n,'b'))]:
        if l!=[i for i in reversed(l)]:
                return False
    return True
sum([z for z in range(1,1000000,2) if ispal(z)])

37.
#reuse sieve function from Q35
primes = sieve()

def istrunc(n):
    N = str(n)
    for it in range(0,len(N)):
        print (N[:it+1],N[it:])
        if int(N[:it+1]) not in primes:
            return False
        if int(N[it:]) not in primes:
            return False
    return True
            
            
sum([pri for pri in primes if istrunc(pri)])

38.
def getmults(x):
    mults = []
    i = 1
    aim = set('123456789')
    while len(mults) < 9:
        mults.extend(str(x*i))
        i += 1
    if len(mults) == 9 and set(mults) == aim:
        return int(''.join(mults))
    return False
    
mits = set()        
for i in range(9000,9877):
    mits.add(getmults(i))
max(mits)

39.
def tris(n):
    count = 0
    #a is the shortest side so 3a < a+b+c = n, hence a < n/3
    for a in range(3,int(n/3)):
        #given we know a+b+c==n, a**2 + b**2 == c**2, solution to the simultaneous equations is:
        b = (2*a*n - n**2)/(2*a - 2*n)
        #checking if b is integer, and removing duplicates
        if round(b)==b and b > a:
            count += 1
    return count
    
def ans():
    highest = 1
    val = 12
    #If a and b are both odd or both even then a**2+b**2 is even. If just one is odd then a**2+b**2 is odd, so a+b+c is even either way.
    for p in range(12, 1001,2):
        ways = tris(p)
        if ways > highest:
            val = p
            highest = ways
    return val
#very quick because I used mathematics instead of an extra for loop
</head>

</html>
